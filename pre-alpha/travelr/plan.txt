4/21/2010

It is now high time to start the documentation!

Additional equilibrium cleanup, including helper function for parsing the control values for the
assignment algorithm.  See the 4/20 entry for requests related to that.

The log functionality for highway assignment is still not quite there.

Why not use factors for node mapping?  Nifty ways to handle zone numbers would be good.

4/20/2010

Spent some time setting up R-Forge.
The assignment set code is much, much simpler and better -- got rid of all the extraneous S3 method stuff.

Finish the equlibrium computation elements.
Simplify the sample data.  Consider creating a network data project that has all of Bar-Gera's sample networks.
Alternatively, consider writing a function that will read Bar-Gera's files directly (without pre-processing) into
a travelr highway.net structure (cleaner).

Next steps:

Drop Chicago-Sketch from test networks - just work with SiouxFalls and RichmondVA.[DONE]
Add a function to produce a list of scalar values for convergence testing (doing some of the network
performance measure functions like gap, rgap, average.excess.cost).  Allow extra values to be tacked
onto the end (for saving stuff like alpha or lambda). [A First cut is in place]
If the control parameter has "logging" enabled, return a "log" element in the result (that will be the
data frame to which each of the list items is appended). [A first cut is in place]
Construct a lambda.search function that finds the lambda that minimizes the objective function, given
a base flow vector and a difference flow vector.[DONE]


4/18/2010

Extensively reworked the C++ code yet again, and added a function to build paths and load all in one step.

This raises the issue that "build.paths" will be considerably less important for assignment sets.  Probably what we want
to do is to be able to iterate across a network set, a set of costs and a demand matrix, all of which need to be
coordinated.  Using something like mapply would be good.  Some rethinking of the assignment set mechanism (which still
isn't making me happy) will be in order.

4/16/2010

The iterative proportional fitting algorithm is now done. Tests are under development (matching examples
from Ortuzar and Willumsen).  Need to test methods other than "absolute" (fraction and percent).

I've cleaned it up so the intercepts now work and we have two versions of the "walk" function (for permuted OD pairs,
versus an explicit list of OD pairs).  Next step is MSA assignment with congestion.  Then on to Frank-Wolfe.

Probably time to go back and clean up the documentation substantially.

The memory fault was tracked back to not rebuilding the network sets with new 0-based parameters.  Everything
is now working again.  This puppy is starting to look like something real!

4/15/2010

Added a preliminary take on iterative proportional fitting.  Completely restructured the C++ code, but it's now crashing
during path building.  Some pointer bollox...  Add detailed access checking.  The path building didn't change much, but
something toasted it.  Construct some checking macros to verify good sense...

4/13/2010

We've cleaned everything up (including jittering the times on the Cube sample network to
ensure unique free-flow paths), and now the assignment produces exactly the same results
-- same link loads, same paths, etc.  Move on to test the skim function to ensure we get
the right matrix answers.  Then we can go back to working on the assignment sets and
adding functionality there.

4/12/2010

Let's move the guts of the construction of the network set (build.network.set) into an internal
structure that is built on 0-based indices.  Edges, offsets and turns are all zero-based and
contain indices that point into the C version of the various vectors (costs, volumes, links).
Do more error-checking in (for example, .walk.paths) to ensure that origins and destinations are
in range, then just convert them to their 0-based representation before passing them along. 

4/12/2010

Fixed a remarkable bug (my fault) in setting attributes on the path structure -- it seemed to
work in the test cases, but perhaps it's because I wasn't setting the attributes previously.
In any case, problem solved.  Next step is getting the AON load to complete.

The AON results are confused compared to Cube, and I think there is some confusion about what
is living in the SPT structure (e.g. are link indices 0-based or 1-based?).  The SPT structure
should retain a 0-based nature (and only be used through the path_functions interface).
When preparing the network set (and that function should be moved to path_functions.R), we need
to convert all the indices to suitable 0-based values.  Then build the paths and all using
0-based equivalents, and when we pass back the trace list, we re-convert to 1-based link indices.

Inside the C-code, we need helper classes to convert an R index (1-based) to a C index (0-based) and
vice versa.  Every time we use an node or link index, it gets converted from R to C if it's coming in,
and it gets converted back from C to R as it's going out.  Functions to which this matters:

.intercept.paths -- not implemented yet, but very important to get right!
.walk.paths -- the origin and destination lists should be in R format going in, and the list of
links that returns should also be in R format; internally, the SPT holds C format indices to the
links.

.shortest.paths -- the edge list is an internal structure like the paths structure, and should
use C indices when it is built (so we can properly identify the links in the stars without having
to convert).

Otherwise, everything should take care of itself.

4/8/2010

Highway Assignment return structure and convergence testing should be defined.  The basic test is
some difference index between the existing equilibrium flows and the shortest paths; these should
generate identical costs at equilibrium.

So we'll need some convergence tests.  When the network is loaded, we'll update the equilibrium
flows, recompute costs, build paths, then do the next AON assignment.  Convergence will test the
equilibrium versus AON flows.  Like the various test assignments, there should be a standard structure
preserving the history (writing out a report, and perhaps also building a data.frame).  Built into
that structure (again like the original tests) are convergence targets (testing one of the various
computed values to be below a threshold, or over a threshold for iterations).  The first one of those
targets to be met will finish the assignment.

For cost function integral, there is R's numeric "integrate" function (which saves having to write
a cost integral function, at the price of having to compute the const function several times for
each link -- a small but perceptible cost).

Highway results include (obviously) the load vector/matrix (equilibrium and most recent shortest
paths), the convergence statistics, plus optional variables to monitor (name=value pairs, passed in
via a ... argument), the convergence targets (optionally a function).

highway.results<-add.assignment.iteration(highway.results,aset,V.eq,V.diff,C.eq,highway.results,convergence,...)
# returns a TRUE or FALSE indicating whether the convergence test has been met
# may also throw diagnostic errors
# assignment set (aset) needed for cost functions, cost integral (to compute gap, etc.)
# may want to extract cost function from aset before starting, and use it directly

We'll probably also need some easy cost diagnostics (so if the shortest paths aren't "shorter" --
one of the standard diagnostics may test that).

Finish Test_02 (construct and save assignment sets)
	Need to load the Richmond network and construct and save some suitable demand subsets
Create Test_03 (run highway assignment algorithms using assignment sets; converge rapidly)
	First test is AON
Create Test_05 (run "deep" highway assignment on SiouxFalls with ParTan -- looking for tiny RGap)

Additional algorithms need additional tests.
Work up a vignette around the ODOT Albany model.

4/5/2010

Consider a general function called "read.network" that works like igraph's "read.graph", with
file, format and additional arguments.  We can handle Cube link and node dbf files (node file
optional), link shapefiles (node shapefile optional), csv files, emme2 network text file,
emme2 network in a databank, and Bar-Gera's TNTP format.

Likewise, a "read.demand.matrix" for some standard matrix formats, including emme2 from a
databank, using the emme2 package, which should be recommended.

3/31/2010

The cost functions and assignment sets should be created for the sample networks as part of the test
process.  Put in a "truck" vehicle class for Richmond (which doesn't use toll facilities, and whose
cost function only looks at all vehicles), and then enlarge the cost function for the other vehicles
to include trucks (to test the full multi-class).  Thus, we can test the "total" assignment set with
trucks/no-trucks and a total vehicle cost, and then add the full multi-class where there is an
additional penalty for trucks.  All of that should end up in an Sweave vignette, with tested code.

Test through the AON and MSA assignments.  Then test the full Frank-Wolfe.  Then test ParTan.  Then
throw in the conjugate gradient search direction.

Need to continue to enlarge and flesh out the documentation files.  Once we're all the way through
Frank-Wolfe, it will be time to hitch it all to the Oregon model and construct an end-to-end setup
that uses travelr for skims and assignment.  Then I can ship that to the ODOT crew for feedback.  I
should also notify Paul Waddell sooner rather than later (and also Andrew Rohne at OKI MPO who has
expressed an interest in R).  I may need to take a couple of days for myself to finish it up and
make it presentable.

3/18/2010

Updated the Richmond network to do additional pre-processing (and to put it into something
resembling Bar-Gera's TNTP format so the same loading code can be used across all the network sets).
So now we have the basis for a highway network data package.  A couple of the small networks (Sioux
Falls, ChicagoSketch) are now in the "data" folder for the base 'travelr' package, along with
the pre-built Richmond network.  The test should continue to build Richmond just as we have
before.  In fact, we could make the tests directory contain the rebuilder (but just for
the networks we want in the 'data' section).

3/16/2010

Completed the script and procesing to get all the example networks ready to use.
Add Hampton Roads to this mix:  we'll want to use our path-builder to construct
the intercepts for the new truck model estimation runs.

We'll also want a Cube setup to put all the networks through their All-or-Nothing paces
to check the path builder -- dumping path traces for some of the smaller networks.

Not all of Bar-Gera's networks have node locations, so it might be fun to construct a
topology builder that builds a set of sticks and organizes them based on distances and
connections, with ambiguities resolved by situating a node as far as possible from
adjacent unconnected nodes.  That would take multiple passes.  There may be an igraph
utility for doing this kind of thing already.

3/15/2010

The assignment set classes are well underway.  We need an example of a full multi-class
cost function.  We also need the mechanisms to compute the necessary equilibrium values
(e.g. a cost function integral, and versions of the various equilibrium metrics such as
gap, lower bound, relative gap, and average excess cost that can be computed from each
type of assignment).

Next up:  write a series of tests that will construct (and using tryCatch, fail to construct)
assignment sets so we can be sure of the logic for error-handling in the various types.
Also build three acceptable assignment sets for single, total and multi-class assignment
that perform AON assignment, so we can see all of those work (including ensuring that
barred links get no traffic -- we'll just exclude toll links for the total assignment set,
and then we'll do a truck/non-truck with truck VDF based on all vehicle volume, and the
non-truck based on raw car volume plus a PCE factor applied to trucks.

While performing the tests, 

Then move on to Frank-Wolfe assignment.  That's when we'll need the cost integral and the
highway assignment results class.

3/14/2010

The assignment set itself should provide the basic elements needed for assignment:  a matrix of
costs used for path building, the network/penalty sets for the paths, a set of volumes resulting
from loading the demands to the shortest paths, and a function for computing cost objectives.

The assignment algorithm alters the link volumes in standard ways and probes for the link flows that
optimize the cost objective.  The assignment set generic functions provide a way to formalize the
algorithms without worrying about single/multi class.

We can handle the different types of assignment by setting up different assignment set types:

assignment.set.single (one class)
assignment.set.total (multiple class demands/volumes, but a single cost function based on total volume)
	The classes only differ by network subset (e.g. SOV/HOV), with different links or penalties, and different demands
assignment.set.multi (multiple classes, with different cost functions for each class based on all volumes)
	The classes differ by cost function, network/penalty, demand

Each class provides implementations for generic functions from which assignment algorithms
are constructed.  If these dispatch on the assignment.set subclass, then that must be the
first parameter, and the function will handle subsequent parameters.

build costs (uses aset cost.functions; generates a list of costs from a list of volumes, or free-flow if no volumes)
build paths (uses aset network descriptors; from a list of costs)
load demand (uses aset demands; from a list of paths)

plus various functions for evaluating statistics (which are functions of a load.set or cost.set)
So we'll classify the list/vector of costs and list/vector of volumes
	compute FW objective
	compute gap
	compute relative gap
	compute lower bound
	compute average excess cost
	perform line search (lambda function) between alternative loads

We could have the highway assignment class and have a function to compute arbitrary assignment
statistics (essentially a factory class that looks up a function in a known list (and we can
register the functions at the start, adding to a list of canned ones)).  Thus, we would pass the
result object, the desired function name, and a list of arguments, plus some options (such as the
iteration number into which to record that value).  All the functions should compute something
returnable as a real (and we can register the function, alongside its formatting characteristics),
without side effects.  There is a master function that can compute and save the values for all
the functions (which will require using named parameters, and all the functions are then called
with the same set of arguments, just using what they need).  This extends the logging mechanism
used in the original assignment tests.

The following two do not need to be generic (operating directly on paths, with auxiliary values)
skim value  (from a list of paths and a list of value vectors (possibly with just one element recycled))
	core function does one path and one value vector
	skim multiple value vectors (e.g. in a data.frame) by using mapply and recyling paths
	skim a single value vector for multiple class paths also by using mapply and recyling value vector
intercept paths
	this one will typically be applied across multiple paths with a single set of interesting links

All of these should have default implementations, which will be the single-class version.
The low-level helpers for path-building, loading, skimming, intercepting should be done for a single class
and as efficient as possible.  The multi-class versions should be set up to be able to call these
repeatedly (by using "lapply" or variants -- so a single argument for the build paths) -- keep everything
inside the class object.  'mapply' looks very promising for this application.

3/12/2010

Achieved the status of having a package that makes it through R CMD check.  This package should
be made "installable" so we can continue testing and processing that way.  A basic test will
be the "load RTC network" script, which seems to work well.

3/8/2010

Next step is to figure out how to do a quality cost.function for each assignment class.  E.g. by
copying data frame columns from the network (to have link variables) into the Better to use an
environment.  Set up a basic BPR function that is part of the package.  Also, set up an example that
does link-by-link function parameters.

3/5/2010

Finish setting up the assignment set consistently.

Then add a function to build the assignment set, given a network and a named list ("classes") of
lists of class parameters.

Class parameters to build:  links to select, penalties to select, demand matrix, cost function
Class elements constructed:  network.set(with edges, offsets, turns), demand, cost.function

Network should be enhanced to include penalty value field so we can get that vector easily (just
include the name of the field; when the assignment set is build, we'll copy that column out of the
penalty table into a penalty.values list element).

3/4/2010

Changing approach to Assignment Set:

class "assignment.set" is intrinsically multi-class.  It has indexing operators
(see the test implementation of AON method).  There will also be operators for
the "intercept.set" class.  Here are the assignment.set implicit elements (accessed
via index, slice or $ operators):

$paths is a list of built path trees (one for each assignment class)
$network.set is the list of path sets constructed from the network (with penalties, etc)
$penalties is the network penalty database
$costs is a function disguised as a data element.  It yields a list of link vectors of costs,
	(one for each class)
$volumes is a list of link vector of volumes (one for each class)
$demand is a list of demand matrices (one for each class)
$assignment is a highway.assignment structure reporting the results of the assignment
	It is a diagnostic.  The final volumes and costs of the assignment are stored
	directly in the assignment set.

$sum.classes is a list of indices for the list elements defining each class (default is
	all classes). This indicates which volumes and costs are summed to generate "all.trips"

the names() function applied to assignment.set will list the valid names of classes, plus
	"all.trips" which is the total volume.  If no classes are explicitly defined when the
	assignment set is created (by supplying a named list of set elements), then a single
	class called "all.trips" is created.

build.paths, load.paths, etc. should inspect their input argument and generate a list of results
(with one result for each item in the input argument): so these will effectively iterate the list
and perform the same operation on each element (we can implement the path functions with the
standard R function "lapply", or perhaps "mapply" if we need multiple elements of the class
definition).

Even though we will pass a list of lists to assignment set, the inner lists will be unpacked into
their elements, and we'll assemble a list of path.sets, a list of links, a list of penalties, a list
of cost.functions and a list of demands, which we can then walk through 

Next Steps (12-5-09):

We want to get everything so it works with R.
Set up the basic R routine for loading and formatting the test networks. [DONE]
	Eventually this should become an R class for taking general network details
	and converting them into the structure needed for the shortestPaths part.

The "length" function for the network should return the number of edges.
Figure out some other useful interface additions to support algorithm construction.

The network setup should interconvert with an igraph graph structure (copy to and from).

Set up an R extension interface to run the shortest path analysis and do some other
things like load and skim the network paths.

Ultimately, we want the path tree to be a class as well.

The classes should have dispatched functions that are useful (e.g. being able to call out a vector
of path elements by indexing with O,D).

