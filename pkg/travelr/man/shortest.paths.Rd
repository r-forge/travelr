%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Copyright (C) 2010 by Jeremy Raw
%   This program is free software; you can redistribute it and/or modify
%   it under the terms of the GNU General Public License as published by
%   the Free Software Foundation; either version 2 of the License, or
%   (at your option) any later version.
% 
%   This program is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%   GNU General Public License for more details.
% 
%   A copy of the GNU General Public License is available at
%   http://www.r-project.org/Licenses/
%   and included in the R distribution (in directory 'share/licenses').
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\name{shortest.paths}
\alias{shortest.paths}
\alias{.shortest.paths}
\alias{.walk.paths}
\alias{.skim.paths}
\alias{.load.paths}
\alias{.build.and.load.paths}
\alias{.intercept.paths}

\title{
Low-Level Functions for Shortest Path Manipulation
}
\description{

These functions construct and manipulate shortest paths based on highway networks.
They are intended for use in building higher-level algorithms.
}
\usage{
.shortest.paths(network.set, costs,penalties=NULL)
.load.paths(paths, demand)
.build.and.load.paths(network.set, costs,demand,penalties=NULL)
.skim.paths(paths, costs, empty.value = 0)
.intercept.paths(paths, links)
.walk.paths(paths, origins, dests, permute=TRUE)
}
\arguments{
  \item{network.set}{
  Network descriptor (generated by \code{\link{build.network.set}})
}
  \item{demand}{
  A matrix of demands between each origin/destination pair
}
  \item{costs}{
  A vector of costs for each link in the network
}
  \item{penalties}{
  A vector of penalty values for each turn penalty in the network
}
  \item{paths}{
  A shortest-path tree for a particular network
}
  \item{empty.value}{
  The value to be used for origin/destination pairs that have no path, and
  also for intrazonal (diagonal) cells
}
  \item{links}{
  A vector selecting links of interest in the network; the intercept matrix will contain true for
  any origin/destination pair whose shortest path crosses one of these links.
}
  \item{origins}{
  A vector of origin zones
}
  \item{dests}{
  A vector of destination zones
}
  \item{permute}{
  If true, returns paths for all combinations of \code{origins} and \code{dests}; otherwise, \code{origins} and
  \code{dests} must be vectors of the same length and paths will only be built for each corresponding origin and
  destination
}
}
\details{

These functions are thin wrappers to \code{C++} code called via the \code{.Call} interface.

The C++ code builds shortest paths using Dijkstra's algorithm with a priority queue and integrated
support for turn (junction) penalties and prohibitions.  The algorithm respects the usual routing
convention of highway networks that treates the origins and destinations of interest as "terminal"
nodes.  Routes are only allowed to leave one of those nodes (the current origin) at a time, and
paths are built only to the other terminal nodes. The resulting path tree contains paths from all
origins to all destinations.  However, these paths span only the terminal nodes, so there may be
intermediate nodes for which a path does not exist for certain origins.

The resulting path tree structure (an \R matrix) can be used with the other functions to perform
operations on vectors of values corresponding to the links, and on matrices whose dimensions
correspond to the number of zones (terminal nodes) in the network, and whose values are associated
with the paths from origins to destinations.

Such vectors of values are often referred to in this documentation as \var{link vectors}, since they
will contain a set of values corresponding to the links in the highway network (and, importantly, in
the same order in which the highway network links were originally presented, corresponding to
\code{order(network$Links$.LinkID)}).

Likewise, the matrices passed to and from these functions are often referred to either as
\var{demand matrices} or \var{trip tables} when they are used for loading the network, and as
\var{skim matrices} when they are returned.

Conventionally in travel demand modeling, the matrices have origins as their rows (first dimension),
and destinations as their columns (second dimension).  This convention dates back to the original
implementation of these models in \code{FORTRAN}, when limited memory in early computers was handled
by processing the matrices one origin at a time.  \R, however, is set up to most efficiently process
matrices one column at a time (the \code{C} convention for multi-dimensional arrays).  None of that
will matter to \pkg{travelr} users since the gnarly details (along with the \code{C} 0-base versus
\R 1-base array index problem) are handled automatically by these wrapper functions.

In general, it is usually more useful to perform these operations through even higher-level
functions which handle multi-class assignment and \dQuote{select link} analysis:
\code{\link{build.paths}}, \code{\link{load.paths}}, \code{\link{build.and.load.paths}},
\code{\link{intercept.paths}}.

The higher-level functions require an \code{\link{assignment.set}} to manage the various parameters.
}
\value{
\code{.shortest.paths} returns a shortest path tree (a species of matrix)

\code{.load.paths} returns a numeric vector of loaded network link values constructed from the demand matrix

\code{.build.and.load.paths} returns a list with elements \code{volumes} and \code{paths} comparable to what would
result by calling \code{.shortest.paths} followed by \code{.load.paths}

\code{.skim.paths} returns a matrix that results from applying \code{FUN} to a vector of link values for each path

\code{.intercept.paths} returns a matrix of of \code{0} or \code{1} indicating whether a path includes a marked link

\code{.walk.paths} returns a list (or a matrix, if the permute option is \code{TRUE}) of vectors of link indices
(integers) showing the links traversed on the requested paths

}
\author{
Jeremy Raw
}
\seealso{
	\code{\link{build.network.set}}, \code{\link{assignment.set}}, \code{\link{highway.assign}} for general operations.

	And the higher level interfaces: \code{\link{build.paths}}, \code{\link{load.paths}},
	\code{\link{build.and.load.paths}}, and \code{\link{intercept.paths}}
}
